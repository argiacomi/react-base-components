Please help with javascript code for the following react component

Name: ButtonBase

Functionality:
The ButtonBase component provides the foundation for building button components in a React application. It handles various user interactions like click, focus, blur, and ripple effects. It also offers a way to customize the component by passing custom props.

Props:

children: React.ReactNode, the content to be rendered inside the button.
className: string, a custom class for styling the button.
component: React.ElementType, the component to render as the button (default: 'button').
disabled: boolean, whether the button is disabled (default: false).
disableTouchRipple: boolean, whether to disable the ripple effect on touch (default: false).
focusRipple: boolean, whether to show the ripple effect on focus (default: false).
onFocusVisible, onBlur, onClick, onContextMenu, onDragLeave, onFocus, onKeyDown, onKeyUp, onMouseDown, onMouseLeave, onMouseUp, onTouchEnd, onTouchMove, onTouchStart: event handlers for various user interactions.
tabIndex: number, the tab index for the button (default: 0).
TouchRippleProps: object, additional properties for the TouchRipple component.
type: string, the type of the button when rendered as a native 'button' element (default: 'button').
State:
This component does not have a local state. It uses various refs to manage focus, ripple effect, and event handling.

Lifecycle methods or hooks:

useEnhancedEffect: a custom hook that uses either useLayoutEffect or useEffect based on the environment.
useIsFocusVisible: a custom hook that determines if the focus is visible and handles focus and blur events.
useForkRef, useEventCallback: custom hooks that manage refs and event callbacks, respectively.
Interactions:
The ButtonBase component handles various user interactions, such as clicks, focus, blur, and ripple effects. It does not directly interact with any other components, services, or APIs, but provides the foundation for building more complex button components that might have those interactions.

Here is a code sample:
import { useCallback, useRef } from 'react';
import { cn } from '../../lib/utils';
import TouchRipple from './TouchRipple';

const useEnhancedEffect =
  typeof window !== 'undefined' ? useLayoutEffect : useEffect;

function isClassComponent(elementType) {
  const { prototype = {} } = elementType;
  return Boolean(prototype.isReactComponent);
}

function elementTypeAcceptingRef(
  props,
  propName,
  componentName,
  location,
  propFullName
) {
  const propValue = props[propName];
  const safePropName = propFullName || propName;

  if (propValue == null || typeof window === 'undefined') {
    return null;
  }

  let warningHint;
  if (typeof propValue === 'function' && !isClassComponent(propValue)) {
    warningHint =
      'Did you accidentally provide a plain function component instead?';
  }

  if (warningHint !== undefined) {
    return new Error(
      `Invalid ${location} \${safePropName} supplied to ${componentName}.` +
        `Expected an element type that can hold a ref. ${warningHint}` +
        `For more information see https://mui.com/r/caveat-with-refs-guide`
    );
  }

  return null;
}

function setRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}

function useForkRef(...refs) {
  return useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }

    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}

function useEventCallback(fn) {
  const ref = useRef(fn);
  useEnhancedEffect(() => {
    ref.current = fn;
  });
  return useCallback((...args) => (0, ref.current)(...args), []);
}

let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;

const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  'datetime-local': true
};

function focusTriggersKeyboardModality(node) {
  const { type, tagName } = node;

  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
    return true;
  }
  if (tagName === 'TEXTAREA' && !node.readOnly) {
    return true;
  }
  if (node.isContentEditable) {
    return true;
  }
  return false;
}

function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}

function handlePointerDown() {
  hadKeyboardEvent = false;
}

function handleVisibilityChange() {
  if (this.visibilityState === 'hidden') {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}

function prepare(doc) {
  doc.addEventListener('keydown', handleKeyDown, true);
  doc.addEventListener('mousedown', handle, handlePointerDown, true);
  doc.addEventListener('pointerdown', handlePointerDown, true);
  doc.addEventListener('touchstart', handlePointerDown, true);
  doc.addEventListener('visibilitychange', handleVisibilityChange, true);
}

function teardown(doc) {
  doc.removeEventListener('keydown', handleKeyDown, true);
  doc.removeEventListener('mousedown', handlePointerDown, true);
  doc.removeEventListener('pointerdown', handlePointerDown, true);
  doc.removeEventListener('touchstart', handlePointerDown, true);
  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);
}

function isFocusVisible(event) {
  const { target } = event;
  try {
    return target.matches(':focus-visible');
  } catch (error) {}
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}

function useIsFocusVisible() {
  const ref = useCallback((node) => {
    if (node != null) {
      prepare(node.ownerDocument);
    }
  }, []);

  const isFocusVisibleRef = useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }

  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}

function ButtonBase(props) {
  const {
    children,
    className,
    component,
    disabled = false,
    disableTouchRipple = false,
    focusRipple = false,
    onFocusVisible,
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    type,
    ...other
  } = props;
  const buttonRef = useRef();
  const rippleRef = useRef();

  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  } = useIsFocusVisible();
  const forkRef = useForkRef(ref, buttonRef);

  const handleMouseDown = useEventCallback((event) => {
    if (onMouseDown) {
      onMouseDown(event);
    }

    if (focusRipple && !disabled) {
      rippleRef.current.start(event);
    }
  });

  const handleMouseUp = useEventCallback((event) => {
    if (onMouseUp) {
      onMouseUp(event);
    }

    if (focusRipple && !disabled) {
      rippleRef.current.stop(event, () => {});
    }
  });

  const handleMouseLeave = useEventCallback((event) => {
    if (onMouseLeave) {
      onMouseLeave(event);
    }
    if (focusRipple && !disabled) {
      rippleRef.current.stop(event, () => {});
    }
  });

  const handleContextMenu = useEventCallback((event) => {
    if (onContextMenu) {
      onContextMenu(event);
    }
    if (focusRipple && !disabled) {
      rippleRef.current.stop(event, () => {});
    }
  });

  const handleDragLeave = useEventCallback((event) => {
    if (onDragLeave) {
      onDragLeave(event);
    }
    if (focusRipple && !disabled) {
      rippleRef.current.stop(event, () => {});
    }
  });

  const handleTouchEnd = useEventCallback((event) => {
    if (onTouchEnd) {
      onTouchEnd(event);
    }
    if (focusRipple && !disabled) {
      rippleRef.current.stop(event, () => {});
    }
  });

  const handleTouchMove = useEventCallback((event) => {
    if (onTouchMove) {
      onTouchMove(event);
    }
    if (focusRipple && !disabled) {
      rippleRef.current.stop(event, () => {});
    }
  });

  const handleTouchStart = useEventCallback((event) => {
    if (onTouchStart) {
      onTouchStart(event);
    }
    if (focusRipple && !disabled) {
      rippleRef.current.start(event);
    }
  });

  const handleClick = useEventCallback((event) => {
    if (disabled) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if (onClick) {
      onClick(event);
    }
  });

  const handleFocus = useEventCallback((event) => {
    if (handleFocusVisible(event)) {
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });

  const handleBlur = useEventCallback((event) => {
    if (handleBlurVisible()) {
      if (onBlur) {
        onBlur(event);
      }
    }
  });
  const handleKeyDown = useEventCallback((event) => {
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.key === ' ' || event.key === 'Enter') {
      event.preventDefault();
    }
  });

  const handleKeyUp = useEventCallback((event) => {
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (event.key === ' ' || event.key === 'Enter') {
      handleClick(event);
    }
  });

  const Component = component || 'button';
  const buttonProps = {};
  if (Component === 'button') {
    buttonProps.disabled = disabled;
    buttonProps.type = type || 'button';
  } else {
    buttonProps.role = 'button';
  }

  const classNames = cn(className, {
    disabled: disabled
  });

  return (
    <Component
      className={classNames}
      tabIndex={disabled ? -1 : tabIndex}
      {...buttonProps}
      {...other}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      onKeyUp={handleKeyUp}
      onMouseDown={handleMouseDown}
      onMouseLeave={handleMouseLeave}
      onMouseUp={handleMouseUp}
      onContextMenu={handleContextMenu}
      onDragLeave={handleDragLeave}
      onTouchEnd={handleTouchEnd}
      onTouchMove={handleTouchMove}
      onTouchStart={handleTouchStart}
      onFocus={handleFocus}
      onBlur={handleBlur}
      ref={forkRef}
    >
      {children}
      {!disableTouchRipple && (
        <TouchRipple ref={rippleRef} {...TouchRippleProps} />
      )}
    </Component>
  );
}

export default ButtonBase;